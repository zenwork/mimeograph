{"version":3,"sources":["webpack:///webpack/bootstrap","webpack:///./src/shared/cooperation-events.js","webpack:///./src/shared/events.js","webpack:///./src/shared/base-element.js","webpack:///./src/shared/child-element.js","webpack:///./src/shared/story.js","webpack:///./node_modules/lit-html/directives/repeat.js","webpack:///./src/components/md-list.js"],"names":["webpackJsonpCallback","data","moduleId","chunkId","chunkIds","moreModules","executeModules","i","resolves","length","installedChunks","push","Object","prototype","hasOwnProperty","call","modules","parentJsonpFunction","shift","deferredModules","apply","checkDeferredModules","result","deferredModule","fulfilled","j","depId","splice","__webpack_require__","s","installedModules","2","exports","module","l","m","c","d","name","getter","o","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","object","property","p","jsonpArray","window","oldJsonpFunction","slice","__webpack_exports__","JOIN_EVENT","PARENT_READY","JOINER_REQUEST","JOINER_ACCEPTED","JOINER_READY","JOINER_CATCHUP","JOINER_LEAVING","Events","[object Object]","joiner","CustomEvent","detail","type","source","acceptor","observeContentChange","ofComponent","handleInputFn","root","observer","MutationObserver","mutations","forEach","mutation","target","nodeName","toUpperCase","input","innerHTML","e","observe","attributes","childList","subtree","dispatchIndexUpdate","listenForIndexUpdate","dispatchSelection","listenForSelection","dispatchStory","listenForStory","indexUpdate","store","index","dispatchEvent","onEventFn","addEventListener","storyDef","event","list","actionFn","BaseElement","_polymer_lit_element_lit_element_js__WEBPACK_IMPORTED_MODULE_0__","id","super","this","Id","Class","TypeError","customElements","define","Error","console","debug","message","attachShadow","ChildElement","_base_element__WEBPACK_IMPORTED_MODULE_0__","_cooperation_events__WEBPACK_IMPORTED_MODULE_1__","ancestor","siblings","parent","sibling","createReady","joinParent","createLeaving","ancestorSelector","that","closest","beforeJoining","onAccepted","hashcode","indexOf","onSiblingReady","join","includes","findIndex","onJoinerLeaving","initStandalone","createRequest","Story","title","content","repeat","_lit_html_js__WEBPACK_IMPORTED_MODULE_0__","createAndInsertPart","containerPart","beforePart","container","startNode","parentNode","beforeNode","undefined","endNode","insertBefore","newPart","options","insertAfterNode","updatePart","part","setValue","commit","insertPartBefore","ref","nextSibling","removePart","generateMap","start","end","map","Map","set","partListCache","WeakMap","keyListCache","items","keyFnOrTemplate","template","keyFn","arguments","oldParts","oldKeys","newParts","newValues","newKeys","newKeyToIndexMap","oldKeyToIndexMap","item","oldHead","oldTail","newHead","newTail","has","oldIndex","oldPart","MdList","lit_html_directives_repeat__WEBPACK_IMPORTED_MODULE_1__","_shared_child_element__WEBPACK_IMPORTED_MODULE_2__","_shared_events__WEBPACK_IMPORTED_MODULE_3__","_shared_story__WEBPACK_IMPORTED_MODULE_4__","properties","inputList","attribute","empty","disconnect","updateList","JSON","parse","trim","ready","itemTemplate","select","keys","renderItems"],"mappings":"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","file":"md-list.js","sourcesContent":[" \t// install a JSONP callback for chunk loading\n \tfunction webpackJsonpCallback(data) {\n \t\tvar chunkIds = data[0];\n \t\tvar moreModules = data[1];\n \t\tvar executeModules = data[2];\n\n \t\t// add \"moreModules\" to the modules object,\n \t\t// then flag all \"chunkIds\" as loaded and fire callback\n \t\tvar moduleId, chunkId, i = 0, resolves = [];\n \t\tfor(;i < chunkIds.length; i++) {\n \t\t\tchunkId = chunkIds[i];\n \t\t\tif(installedChunks[chunkId]) {\n \t\t\t\tresolves.push(installedChunks[chunkId][0]);\n \t\t\t}\n \t\t\tinstalledChunks[chunkId] = 0;\n \t\t}\n \t\tfor(moduleId in moreModules) {\n \t\t\tif(Object.prototype.hasOwnProperty.call(moreModules, moduleId)) {\n \t\t\t\tmodules[moduleId] = moreModules[moduleId];\n \t\t\t}\n \t\t}\n \t\tif(parentJsonpFunction) parentJsonpFunction(data);\n\n \t\twhile(resolves.length) {\n \t\t\tresolves.shift()();\n \t\t}\n\n \t\t// add entry modules from loaded chunk to deferred list\n \t\tdeferredModules.push.apply(deferredModules, executeModules || []);\n\n \t\t// run deferred modules when all chunks ready\n \t\treturn checkDeferredModules();\n \t};\n \tfunction checkDeferredModules() {\n \t\tvar result;\n \t\tfor(var i = 0; i < deferredModules.length; i++) {\n \t\t\tvar deferredModule = deferredModules[i];\n \t\t\tvar fulfilled = true;\n \t\t\tfor(var j = 1; j < deferredModule.length; j++) {\n \t\t\t\tvar depId = deferredModule[j];\n \t\t\t\tif(installedChunks[depId] !== 0) fulfilled = false;\n \t\t\t}\n \t\t\tif(fulfilled) {\n \t\t\t\tdeferredModules.splice(i--, 1);\n \t\t\t\tresult = __webpack_require__(__webpack_require__.s = deferredModule[0]);\n \t\t\t}\n \t\t}\n \t\treturn result;\n \t}\n\n \t// The module cache\n \tvar installedModules = {};\n\n \t// object to store loaded and loading chunks\n \t// undefined = chunk not loaded, null = chunk preloaded/prefetched\n \t// Promise = chunk loading, 0 = chunk loaded\n \tvar installedChunks = {\n \t\t2: 0\n \t};\n\n \tvar deferredModules = [];\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \tvar jsonpArray = window[\"webpackJsonp\"] = window[\"webpackJsonp\"] || [];\n \tvar oldJsonpFunction = jsonpArray.push.bind(jsonpArray);\n \tjsonpArray.push = webpackJsonpCallback;\n \tjsonpArray = jsonpArray.slice();\n \tfor(var i = 0; i < jsonpArray.length; i++) webpackJsonpCallback(jsonpArray[i]);\n \tvar parentJsonpFunction = oldJsonpFunction;\n\n\n \t// add entry module to deferred list\n \tdeferredModules.push([21,0]);\n \t// run deferred modules when ready\n \treturn checkDeferredModules();\n","export const JOIN_EVENT = 'md-join';\nexport const PARENT_READY = 'md-acceptor-ready';\nexport const JOINER_REQUEST = 'md-join-request';\nexport const JOINER_ACCEPTED = 'md-join-accepted';\nexport const JOINER_READY = 'md-join-ready';\nexport const JOINER_CATCHUP = 'md-join-catchup';\nexport const JOINER_LEAVING = 'md-join-leaving';\n\n/**\n * Events used for parent-child collaboration\n */\nexport class Events {\n\n\tstatic createRequest(joiner) {\n\t\tlet details = {detail:{type:JOINER_REQUEST, source:joiner}};\n\t\treturn new CustomEvent(JOIN_EVENT, details);\n\t}\n\n\tstatic createAccept(acceptor) {\n\t\tlet details = {detail:{type:JOINER_ACCEPTED, source:acceptor}};\n\t\treturn new CustomEvent(JOIN_EVENT, details);\n\t}\n\n\tstatic createReady(joiner) {\n\t\tlet details = {detail:{type:JOINER_READY, source:joiner}};\n\t\treturn new CustomEvent(JOIN_EVENT, details);\n\t}\n\n\tstatic createCatchup(joiner) {\n\t\tlet details = {detail:{type:JOINER_CATCHUP, source:joiner}};\n\t\treturn new CustomEvent(JOIN_EVENT, details);\n\t}\n\n\tstatic createAcceptorReady(joiner) {\n\t\tlet details = {detail:{type:PARENT_READY, source:joiner}};\n\t\treturn new CustomEvent(JOIN_EVENT, details);\n\t}\n\n\tstatic createLeaving(joiner) {\n\t\tlet details = {detail:{type:JOINER_LEAVING, source:joiner}};\n\t\treturn new CustomEvent(JOIN_EVENT, details);\n\t}\n}\n","/**\n * util function that creates and triggers the observation of the content of a given node.\n *\n * @param ofComponent component's name\n * @param handleMutationFn function to handle the mutation\n * @param root node on which to attach the observer\n * @returns {MutationObserver}\n */\nexport function observeContentChange(ofComponent, handleInputFn, root) {\n\t// Options for the observer (which mutations to observe)\n\tconst config = {attributes:false, childList:true, subtree:false};\n\n\tconst observer = new MutationObserver(function (mutations) {\n\t\tmutations.forEach(function (mutation) {\n\t\t\tif (mutation.type === 'childList' && mutation.target.nodeName === ofComponent.toUpperCase()) {\n\t\t\t\tlet input = mutation.target.innerHTML;\n\t\t\t\ttry {\n\t\t\t\t\tif (input) {\n\t\t\t\t\t\thandleInputFn(input, root);\n\t\t\t\t\t}\n\t\t\t\t} catch (e) {\n\t\t\t\t\tthrow e;\n\t\t\t\t}\n\n\t\t\t}\n\t\t});\n\t});\n\n\t// Start observing the target node for configured mutations\n\tobserver.observe(root, config);\n\treturn observer;\n}\n\nconst indexUpdate = 'md-store-index-updated';\n\nexport function dispatchIndexUpdate(store, index) {\n\t// console.log('>>>: index update');\n\tstore.dispatchEvent(new CustomEvent(indexUpdate, {detail:index}));\n}\n\nexport function listenForIndexUpdate(store, onEventFn) {\n\t// console.log('<<<: index update');\n\tstore.addEventListener(indexUpdate, onEventFn);\n}\n\nexport function dispatchSelection(root, storyDef) {\n\tlet event = new CustomEvent('md-list-selection', {detail:storyDef});\n\troot.dispatchEvent(event);\n}\n\nexport function listenForSelection(list, actionFn) {\n\t// console.log('<<<: selection');\n\tlist.addEventListener('md-list-selection', actionFn);\n}\n\nexport function dispatchStory(root, storyDef) {\n\tlet event = new CustomEvent('md-store-story', {detail:storyDef});\n\troot.dispatchEvent(event);\n}\n\nexport function listenForStory(store, actionFn) {\n\t// console.log('<<<: selection');\n\tif(store) store.addEventListener('md-store-story', actionFn);\n}\n","import { LitElement } from '@polymer/lit-element/lit-element.js';\n\nlet id=0;\nexport class BaseElement extends LitElement {\n\n\tconstructor() {\n\t\tsuper();\n\t\tthis.Id = id++;\n\t\tthis.Class = new.target.name;\n\t\t// console.debug(`constructing: ${this.Class}:${this.Id}`);\n\t\tif (new.target === BaseElement) {\n\t\t\tthrow new TypeError('Cannot construct BaseElement instances directly');\n\t\t}\n\n\t}\n\n\thashcode() {\n\t\treturn this.Class + ':' + this.Id;\n\t}\n\n\tconnectedCallback() {\n\t\t// console.debug(`connected: ${this.Class}`);\n\t}\n\n\tstatic define(name) {\n\t\ttry {\n\t\t\tconst Class = this;\n\t\t\tif (name) {\n\t\t\t\twindow.customElements.define(name, Class);\n\t\t\t} else if (this.name) {\n\t\t\t\twindow.customElements.define(this.name, Class);\n\t\t\t} else {\n\t\t\t\tthrow Error('either define [static this.name] or provide a valid name to the define(name) function');\n\t\t\t}\n\t\t} catch (e) {\n\t\t\tconsole.debug(`swallowing custom component define() for [${name?name:this.name}] error: ${e.message}`);\n\t\t}\n\t}\n\n\tcreateRenderRoot() {\n\t\t//should use a 'closed' shadow dom but must be open for testing!!! Need to figure this out\n\t\treturn this.attachShadow({mode:'open'});\n\t}\n}\n","import { BaseElement } from './base-element';\nimport {\n\tEvents,\n\tJOIN_EVENT,\n\tJOINER_ACCEPTED,\n\tJOINER_CATCHUP,\n\tJOINER_LEAVING,\n\tJOINER_READY,\n\tPARENT_READY\n} from './cooperation-events';\n\nexport class ChildElement extends BaseElement {\n\tstatic get name() {return 'md-child';}\n\n\tconstructor() {\n\t\tsuper();\n\t\tthis.ancestor = null;\n\t\tthis.siblings = [];\n\t\t// console.debug(`constructing ${this.Class}`);\n\t}\n\n\t/**\n\t * Called before requesting to join parent\n\t */\n\tbeforeJoining() {}\n\n\t/**\n\t * Called when the element will run in alone without the support of a containing parent\n\t */\n\tinitStandalone() {}\n\n\t/**\n\t * Called when this element's request to join is accepted. Any initialization with the parent can be done then.\n\t * @param parent\n\t */\n\tonAccepted(parent) {}\n\n\t/**\n\t * Called when a sibling elements have called ready(). It will only be called once per lide-cycle.\n\t * @param sibling the ready element\n\t */\n\tonSiblingReady(sibling) {}\n\n\t/**\n\t * Called when a component that has joined is leaving. It will only be called once\n\t * @param sibling the leaving element\n\t */\n\tonJoinerLeaving(sibling) {}\n\n\t/**\n\t * Must be called when the element is ready to collaborate. Other elements colaborating under the same parent\n\t * will receive a ready event from this element only after ready() has been called.\n\t */\n\tready() {this.ancestor.dispatchEvent(Events.createReady(this));}\n\n\t/**\n\t * Custom Element standard call when element instance connected to DOM\n\t */\n\tconnectedCallback() {\n\t\t// console.debug(`${this.Class} is connected`);\n\t\tthis.joinParent('md-parent');\n\t}\n\n\t/**\n\t * Custom Element standard call when element instance disconnected from DOM\n\t */\n\tdisconnectedCallback() {\n\t\tthis.ancestor.dispatchEvent(Events.createLeaving(this));\n\t}\n\n\t/**\n\t * Initialize the component in standalone or cooperative mode.\n\t * @param ancestorSelector  a selector to find the ancestor that accepts joiners\n\t * @returns {string} 'cooperative' if attempted to register with parent; 'standalone' otherwise\n\t */\n\tjoinParent(ancestorSelector) {\n\t\t// console.debug(`${this.Class}:${this.Id} trying to join ${ancestorSelector}`);\n\t\tconst that = this;\n\t\t//if no parent provided then standalone mode\n\t\tif (!ancestorSelector) {\n\t\t\t// console.debug(`${this.Class} initializing for standalone`);\n\t\t\tthis.initStandalone();\n\t\t\treturn 'standalone';\n\t\t}\n\n\t\t//find parent\n\t\tconst ancestor = this.ancestor = this.closest(ancestorSelector);\n\n\t\tif (ancestor) {\n\t\t\t// console.debug(`${this.Class} initializing for cooperation`);\n\t\t\tthis.beforeJoining();\n\t\t\tthis.addEventListener(JOIN_EVENT, localEventAction);\n\t\t\tthis.ancestor.addEventListener(JOIN_EVENT, sharedEventAction);\n\t\t\tthis.join();\n\t\t\treturn 'cooperative';\n\t\t} else {\n\t\t\t// console.debug(`${this.Class} initializing standalone mode because no parent [${ancestorSelector}] was\n\t\t\t// found`);\n\t\t\tthis.initStandalone();\n\t\t\treturn 'standalone';\n\t\t}\n\n\t\tfunction localEventAction(event) {\n\t\t\tlet detail = event.detail;\n\t\t\tlet source = detail.source;\n\t\t\tlet type = detail.type;\n\t\t\tswitch (type) {\n\t\t\t\tcase JOINER_ACCEPTED:\n\t\t\t\t\tthat.onAccepted(source);\n\t\t\t\t\tbreak;\n\t\t\t\tcase JOINER_CATCHUP:\n\t\t\t\t\tif (source.hashcode() !== that.hashcode() && that.siblings.indexOf(source.hashcode()) < 0) {\n\t\t\t\t\t\tconsole.debug(`${that.hashcode()} catching up with ${source.hashcode()}`);\n\t\t\t\t\t\tthat.siblings.push(source.hashcode());\n\t\t\t\t\t\tthat.onSiblingReady(source);\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tfunction sharedEventAction(event) {\n\t\t\tlet detail = event.detail;\n\t\t\tlet source = detail.source;\n\n\t\t\tif (notFromSelf()) {\n\t\t\t\tlet type = detail.type;\n\t\t\t\tswitch (type) {\n\t\t\t\t\tcase PARENT_READY:\n\t\t\t\t\t\t//join because parent indicates it will accept requests\n\t\t\t\t\t\tthat.join();\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase JOINER_READY:\n\t\t\t\t\t\tif (!that.siblings.includes(source.hashcode())) {\n\t\t\t\t\t\t\t// console.debug(`${that.hashcode()} receiving ready from ${source.hashcode()}`);\n\t\t\t\t\t\t\tthat.siblings.push(source.hashcode());\n\t\t\t\t\t\t\tthat.onSiblingReady(source);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase JOINER_LEAVING:\n\t\t\t\t\t\tif (that.siblings.indexOf(source.hashcode()) > -1) {\n\t\t\t\t\t\t\tdelete that.siblings[that.siblings.findIndex((i) => i === source.hashcode())];\n\t\t\t\t\t\t\tthat.onJoinerLeaving(source);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfunction notFromSelf() {\n\t\t\t\treturn source.hashcode() ? source.hashcode() !== that.hashcode() : false;\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * dispatch a join request\n\t */\n\tjoin() {\n\t\tif (this.ancestor) this.ancestor.dispatchEvent(Events.createRequest(this));\n\t}\n\n}\n\n\n","/**\n * Story Description\n */\nexport class Story {\n\tconstructor(key, title, content) {\n\t\tthis.key = key;\n\t\tthis.title = title;\n\t\tthis.content = content;\n\t}\n}\n","/**\n * @license\n * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.\n * This code may only be used under the BSD style license found at\n * http://polymer.github.io/LICENSE.txt\n * The complete set of authors may be found at\n * http://polymer.github.io/AUTHORS.txt\n * The complete set of contributors may be found at\n * http://polymer.github.io/CONTRIBUTORS.txt\n * Code distributed by Google as part of the polymer project is also\n * subject to an additional IP rights grant found at\n * http://polymer.github.io/PATENTS.txt\n */\nimport { createMarker, directive, NodePart, removeNodes, reparentNodes } from '../lit-html.js';\n// Helper functions for manipulating parts\n// TODO(kschaaf): Refactor into Part API?\nconst createAndInsertPart = (containerPart, beforePart) => {\n    const container = containerPart.startNode.parentNode;\n    const beforeNode = beforePart === undefined ? containerPart.endNode :\n        beforePart.startNode;\n    const startNode = container.insertBefore(createMarker(), beforeNode);\n    container.insertBefore(createMarker(), beforeNode);\n    const newPart = new NodePart(containerPart.options);\n    newPart.insertAfterNode(startNode);\n    return newPart;\n};\nconst updatePart = (part, value) => {\n    part.setValue(value);\n    part.commit();\n    return part;\n};\nconst insertPartBefore = (containerPart, part, ref) => {\n    const container = containerPart.startNode.parentNode;\n    const beforeNode = ref ? ref.startNode : containerPart.endNode;\n    const endNode = part.endNode.nextSibling;\n    if (endNode !== beforeNode) {\n        reparentNodes(container, part.startNode, endNode, beforeNode);\n    }\n};\nconst removePart = (part) => {\n    removeNodes(part.startNode.parentNode, part.startNode, part.endNode.nextSibling);\n};\n// Helper for generating a map of array item to its index over a subset\n// of an array (used to lazily generate `newKeyToIndexMap` and\n// `oldKeyToIndexMap`)\nconst generateMap = (list, start, end) => {\n    const map = new Map();\n    for (let i = start; i <= end; i++) {\n        map.set(list[i], i);\n    }\n    return map;\n};\n// Stores previous ordered list of parts and map of key to index\nconst partListCache = new WeakMap();\nconst keyListCache = new WeakMap();\nexport function repeat(items, keyFnOrTemplate, template) {\n    let keyFn;\n    if (arguments.length === 2) {\n        template = keyFnOrTemplate;\n    }\n    else if (arguments.length === 3) {\n        keyFn = keyFnOrTemplate;\n    }\n    return directive((containerPart) => {\n        // Old part & key lists are retrieved from the last update (associated with\n        // the part for this instance of the directive)\n        const oldParts = partListCache.get(containerPart) || [];\n        const oldKeys = keyListCache.get(containerPart) || [];\n        // New part list will be built up as we go (either reused from old parts or\n        // created for new keys in this update). This is saved in the above cache\n        // at the end of the update.\n        const newParts = [];\n        // New value list is eagerly generated from items along with a parallel\n        // array indicating its key.\n        const newValues = [];\n        const newKeys = [];\n        let index = 0;\n        for (const item of items) {\n            newKeys[index] = keyFn ? keyFn(item, index) : index;\n            newValues[index] = template(item, index);\n            index++;\n        }\n        // Maps from key to index for current and previous update; these are\n        // generated lazily only when needed as a performance optimization, since\n        // they are only required for multiple non-contiguous changes in the list,\n        // which are less common.\n        let newKeyToIndexMap;\n        let oldKeyToIndexMap;\n        // Head and tail pointers to old parts and new values\n        let oldHead = 0;\n        let oldTail = oldParts.length - 1;\n        let newHead = 0;\n        let newTail = newValues.length - 1;\n        // Overview of O(n) reconciliation algorithm (general approach based on\n        // ideas found in ivi, vue, snabbdom, etc.):\n        //\n        // * We start with the list of old parts and new values (and arrays of\n        //   their respective keys), head/tail pointers into each, and we build\n        //   up the new list of parts by updating (and when needed, moving) old\n        //   parts or creating new ones. The initial scenario might look like this\n        //   (for brevity of the diagrams, the numbers in the array reflect keys\n        //   associated with the old parts or new values, although keys and\n        //   parts/values are actually stored in parallel arrays indexed using the\n        //   same head/tail pointers):\n        //\n        //      oldHead v                 v oldTail\n        //   oldKeys:  [0, 1, 2, 3, 4, 5, 6]\n        //   newParts: [ ,  ,  ,  ,  ,  ,  ]\n        //   newKeys:  [0, 2, 1, 4, 3, 7, 6] <- reflects the user's new item order\n        //      newHead ^                 ^ newTail\n        //\n        // * Iterate old & new lists from both sides, updating, swapping, or\n        //   removing parts at the head/tail locations until neither head nor tail\n        //   can move.\n        //\n        // * Example below: keys at head pointers match, so update old part 0 in-\n        //   place (no need to move it) and record part 0 in the `newParts` list.\n        //   The last thing we do is advance the `oldHead` and `newHead` pointers\n        //   (will be reflected in the next diagram).\n        //\n        //      oldHead v                 v oldTail\n        //   oldKeys:  [0, 1, 2, 3, 4, 5, 6]\n        //   newParts: [0,  ,  ,  ,  ,  ,  ] <- heads matched: update 0 and\n        //   newKeys:  [0, 2, 1, 4, 3, 7, 6]    advance both oldHead & newHead\n        //      newHead ^                 ^ newTail\n        //\n        // * Example below: head pointers don't match, but tail pointers do, so\n        //   update part 6 in place (no need to move it), and record part 6 in the\n        //   `newParts` list. Last, advance the `oldTail` and `oldHead` pointers.\n        //\n        //         oldHead v              v oldTail\n        //   oldKeys:  [0, 1, 2, 3, 4, 5, 6]\n        //   newParts: [0,  ,  ,  ,  ,  , 6] <- tails matched: update 6 and\n        //   newKeys:  [0, 2, 1, 4, 3, 7, 6]    advance both oldTail & newTail\n        //         newHead ^              ^ newTail\n        //\n        // * If neither head nor tail match; next check if one of the old head/tail\n        //   items was removed. We first need to generate the reverse map of new\n        //   keys to index (`newKeyToIndexMap`), which is done once lazily as a\n        //   performance optimization, since we only hit this case if multiple\n        //   non-contiguous changes were made. Note that for contiguous removal\n        //   anywhere in the list, the head and tails would advance from either end\n        //   and pass each other before we get to this case and removals would be\n        //   handled in the final while loop without needing to generate the map.\n        //\n        // * Example below: The key at `oldTail` was removed (no longer in the\n        //   `newKeyToIndexMap`), so remove that part from the DOM and advance just\n        //   the `oldTail` pointer.\n        //\n        //         oldHead v           v oldTail\n        //   oldKeys:  [0, 1, 2, 3, 4, 5, 6]\n        //   newParts: [0,  ,  ,  ,  ,  , 6] <- 5 not in new map; remove 5 and\n        //   newKeys:  [0, 2, 1, 4, 3, 7, 6]    advance oldTail\n        //         newHead ^           ^ newTail\n        //\n        // * Once head and tail cannot move, any mismatches are due to either new or\n        //   moved items; if a new key is in the previous \"old key to old index\"\n        //   map, move the old part to the new location, otherwise create and insert\n        //   a new part. Note that when moving an old part we null its position in\n        //   the oldParts array if it lies between the head and tail so we know to\n        //   skip it when the pointers get there.\n        //\n        // * Example below: neither head nor tail match, and neither were removed;\n        //   so find the `newHead` key in the `oldKeyToIndexMap`, and move that old\n        //   part's DOM into the next head position (before `oldParts[oldHead]`).\n        //   Last, null the part in the `oldPart` array since it was somewhere in\n        //   the remaining oldParts still to be scanned (between the head and tail\n        //   pointers) so that we know to skip that old part on future iterations.\n        //\n        //         oldHead v        v oldTail\n        //   oldKeys:  [0, 1, -, 3, 4, 5, 6]\n        //   newParts: [0, 2,  ,  ,  ,  , 6] <- stuck; update & move 2 into place\n        //   newKeys:  [0, 2, 1, 4, 3, 7, 6]    and advance newHead\n        //         newHead ^           ^ newTail\n        //\n        // * Note that for moves/insertions like the one above, a part inserted at\n        //   the head pointer is inserted before the current `oldParts[oldHead]`,\n        //   and a part inserted at the tail pointer is inserted before\n        //   `newParts[newTail+1]`. The seeming asymmetry lies in the fact that new\n        //   parts are moved into place outside in, so to the right of the head\n        //   pointer are old parts, and to the right of the tail pointer are new\n        //   parts.\n        //\n        // * We always restart back from the top of the algorithm, allowing matching\n        //   and simple updates in place to continue...\n        //\n        // * Example below: the head pointers once again match, so simply update\n        //   part 1 and record it in the `newParts` array.  Last, advance both head\n        //   pointers.\n        //\n        //         oldHead v        v oldTail\n        //   oldKeys:  [0, 1, -, 3, 4, 5, 6]\n        //   newParts: [0, 2, 1,  ,  ,  , 6] <- heads matched; update 1 and\n        //   newKeys:  [0, 2, 1, 4, 3, 7, 6]    advance both oldHead & newHead\n        //            newHead ^        ^ newTail\n        //\n        // * As mentioned above, items that were moved as a result of being stuck\n        //   (the final else clause in the code below) are marked with null, so we\n        //   always advance old pointers over these so we're comparing the next\n        //   actual old value on either end.\n        //\n        // * Example below: `oldHead` is null (already placed in newParts), so\n        //   advance `oldHead`.\n        //\n        //            oldHead v     v oldTail\n        //   oldKeys:  [0, 1, -, 3, 4, 5, 6] // old head already used; advance\n        //   newParts: [0, 2, 1,  ,  ,  , 6] // oldHead\n        //   newKeys:  [0, 2, 1, 4, 3, 7, 6]\n        //               newHead ^     ^ newTail\n        //\n        // * Note it's not critical to mark old parts as null when they are moved\n        //   from head to tail or tail to head, since they will be outside the\n        //   pointer range and never visited again.\n        //\n        // * Example below: Here the old tail key matches the new head key, so\n        //   the part at the `oldTail` position and move its DOM to the new\n        //   head position (before `oldParts[oldHead]`). Last, advance `oldTail`\n        //   and `newHead` pointers.\n        //\n        //               oldHead v  v oldTail\n        //   oldKeys:  [0, 1, -, 3, 4, 5, 6]\n        //   newParts: [0, 2, 1, 4,  ,  , 6] <- old tail matches new head: update\n        //   newKeys:  [0, 2, 1, 4, 3, 7, 6]   & move 4, advance oldTail & newHead\n        //               newHead ^     ^ newTail\n        //\n        // * Example below: Old and new head keys match, so update the old head\n        //   part in place, and advance the `oldHead` and `newHead` pointers.\n        //\n        //               oldHead v oldTail\n        //   oldKeys:  [0, 1, -, 3, 4, 5, 6]\n        //   newParts: [0, 2, 1, 4, 3,   ,6] <- heads match: update 3 and advance\n        //   newKeys:  [0, 2, 1, 4, 3, 7, 6]    oldHead & newHead\n        //                  newHead ^  ^ newTail\n        //\n        // * Once the new or old pointers move past each other then all we have\n        //   left is additions (if old list exhausted) or removals (if new list\n        //   exhausted). Those are handled in the final while loops at the end.\n        //\n        // * Example below: `oldHead` exceeded `oldTail`, so we're done with the\n        //   main loop.  Create the remaining part and insert it at the new head\n        //   position, and the update is complete.\n        //\n        //                   (oldHead > oldTail)\n        //   oldKeys:  [0, 1, -, 3, 4, 5, 6]\n        //   newParts: [0, 2, 1, 4, 3, 7 ,6] <- create and insert 7\n        //   newKeys:  [0, 2, 1, 4, 3, 7, 6]\n        //                     newHead ^ newTail\n        //\n        // * Note that the order of the if/else clauses is not important to the\n        //   algorithm, as long as the null checks come first (to ensure we're\n        //   always working on valid old parts) and that the final else clause\n        //   comes last (since that's where the expensive moves occur). The\n        //   order of remaining clauses is is just a simple guess at which cases\n        //   will be most common.\n        //\n        // * TODO(kschaaf) Note, we could calculate the longest increasing\n        //   subsequence (LIS) of old items in new position, and only move those not\n        //   in the LIS set. However that costs O(nlogn) time and adds a bit more\n        //   code, and only helps make rare types of mutations require fewer moves.\n        //   The above handles removes, adds, reversal, swaps, and single moves of\n        //   contiguous items in linear time, in the minimum number of moves. As\n        //   the number of multiple moves where LIS might help approaches a random\n        //   shuffle, the LIS optimization becomes less helpful, so it seems not\n        //   worth the code at this point. Could reconsider if a compelling case\n        //   arises.\n        while (oldHead <= oldTail && newHead <= newTail) {\n            if (oldParts[oldHead] === null) {\n                // `null` means old part at head has already been used below; skip\n                oldHead++;\n            }\n            else if (oldParts[oldTail] === null) {\n                // `null` means old part at tail has already been used below; skip\n                oldTail--;\n            }\n            else if (oldKeys[oldHead] === newKeys[newHead]) {\n                // Old head matches new head; update in place\n                newParts[newHead] = updatePart(oldParts[oldHead], newValues[newHead]);\n                oldHead++;\n                newHead++;\n            }\n            else if (oldKeys[oldTail] === newKeys[newTail]) {\n                // Old tail matches new tail; update in place\n                newParts[newTail] = updatePart(oldParts[oldTail], newValues[newTail]);\n                oldTail--;\n                newTail--;\n            }\n            else if (oldKeys[oldHead] === newKeys[newTail]) {\n                // Old head matches new tail; update and move to new tail\n                newParts[newTail] = updatePart(oldParts[oldHead], newValues[newTail]);\n                insertPartBefore(containerPart, oldParts[oldHead], newParts[newTail + 1]);\n                oldHead++;\n                newTail--;\n            }\n            else if (oldKeys[oldTail] === newKeys[newHead]) {\n                // Old tail matches new head; update and move to new head\n                newParts[newHead] = updatePart(oldParts[oldTail], newValues[newHead]);\n                insertPartBefore(containerPart, oldParts[oldTail], oldParts[oldHead]);\n                oldTail--;\n                newHead++;\n            }\n            else {\n                if (newKeyToIndexMap === undefined) {\n                    // Lazily generate key-to-index maps, used for removals & moves below\n                    newKeyToIndexMap = generateMap(newKeys, newHead, newTail);\n                    oldKeyToIndexMap = generateMap(oldKeys, oldHead, oldTail);\n                }\n                if (!newKeyToIndexMap.has(oldKeys[oldHead])) {\n                    // Old head is no longer in new list; remove\n                    removePart(oldParts[oldHead]);\n                    oldHead++;\n                }\n                else if (!newKeyToIndexMap.has(oldKeys[oldTail])) {\n                    // Old tail is no longer in new list; remove\n                    removePart(oldParts[oldTail]);\n                    oldTail--;\n                }\n                else {\n                    // Any mismatches at this point are due to additions or moves; see if\n                    // we have an old part we can reuse and move into place\n                    const oldIndex = oldKeyToIndexMap.get(newKeys[newHead]);\n                    const oldPart = oldIndex !== undefined ? oldParts[oldIndex] : null;\n                    if (oldPart === null) {\n                        // No old part for this value; create a new one and insert it\n                        const newPart = createAndInsertPart(containerPart, oldParts[oldHead]);\n                        updatePart(newPart, newValues[newHead]);\n                        newParts[newHead] = newPart;\n                    }\n                    else {\n                        // Reuse old part\n                        newParts[newHead] = updatePart(oldPart, newValues[newHead]);\n                        insertPartBefore(containerPart, oldPart, oldParts[oldHead]);\n                        // This marks the old part as having been used, so that it will be\n                        // skipped in the first two checks above\n                        oldParts[oldIndex] = null;\n                    }\n                    newHead++;\n                }\n            }\n        }\n        // Add parts for any remaining new values\n        while (newHead <= newTail) {\n            // For all remaining additions, we insert before last new tail,\n            // since old pointers are no longer valid\n            const newPart = createAndInsertPart(containerPart, newParts[newTail + 1]);\n            updatePart(newPart, newValues[newHead]);\n            newParts[newHead++] = newPart;\n        }\n        // Remove any remaining unused old parts\n        while (oldHead <= oldTail) {\n            const oldPart = oldParts[oldHead++];\n            if (oldPart !== null) {\n                removePart(oldPart);\n            }\n        }\n        // Save order of new parts for next round\n        partListCache.set(containerPart, newParts);\n        keyListCache.set(containerPart, newKeys);\n    });\n}\n//# sourceMappingURL=repeat.js.map","import { html } from '@polymer/lit-element/lit-element.js';\nimport { repeat } from 'lit-html/directives/repeat';\nimport { ChildElement } from '../shared/child-element';\nimport { dispatchSelection, listenForIndexUpdate, observeContentChange } from '../shared/events';\nimport { Story } from '../shared/story';\n\nexport class MdList extends ChildElement {\n\n\tstatic get name() { return 'md-list';}\n\n\tstatic get properties() {\n\t\treturn {\n\t\t\tinputList:{type:Object, attribute:false}\n\t\t};\n\t}\n\n\tconstructor() {\n\t\tsuper();\n\t\tthis.empty = {};\n\t}\n\n\tconnectedCallback() {\n\t\tthis.inputList = this.empty;\n\t\tsuper.joinParent('md-view');\n\t}\n\n\tdisconnectedCallback() {\n\t\tif (this.observer) this.observer.disconnect();\n\t}\n\n\tinitStandalone() {\n\t\tif (this.innerHTML) {\n\t\t\tupdateList(this.innerHTML, this);\n\t\t}\n\t\tthis.observer = observeContentChange('MD-LIST', updateList, this);\n\n\t\tfunction updateList(input, root) {\n\t\t\troot.inputList = JSON.parse(input.trim());\n\t\t}\n\n\t}\n\n\tonSiblingReady(sibling) {\n\t\tswitch (sibling.Class) {\n\t\t\tcase 'md-store':\n\t\t\tcase 'md-static-store':\n\t\t\t\tlistenForIndexUpdate(sibling,\n\t\t\t\t                     (event) => {\n\t\t\t\t\t                     return this.inputList = event.detail;\n\t\t\t\t                     });\n\t\t\t\tsuper.ready();\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\trender() {\n\t\tlet itemTemplate = (key) => html`<li><a href=\"#\" @click=${() => {\n\t\t\tthis.select(this, key);\n\t\t}}>${this.inputList[key]}</a></li>`;\n\n\t\tfunction renderItems(inputList, empty) {\n\t\t\tif (inputList === empty) {\n\t\t\t\treturn html`<li>no items</li>`;\n\t\t\t} else {\n\t\t\t\treturn html`${repeat(Object.keys(inputList),\n\t\t\t\t                     (key) => {return key;},\n\t\t\t\t                     (key) => {return itemTemplate(key);})}`;\n\t\t\t}\n\t\t}\n\n\t\treturn html` <section><ul>${renderItems(this.inputList, this.empty)}</ul></section>`;\n\n\t}\n\n\tselect(root, key) {\n\t\tdispatchSelection(root, new Story(key, this.inputList[key]));\n\t}\n}\n\nMdList.define();\n\n"],"sourceRoot":""}